#!/usr/bin/env python

import sys
import os
import re
import time
import fcntl

VERSION='3.0.0'

try:
	from xdg.BaseDirectory import xdg_config_home
except ImportError:
	xdg_config_home = os.path.expanduser('~/.config')


"""
	lockfile that is initialized in acquire_lock() but needs to be global
	so that the GC does not clean this up and close the file prematurely.
	If that would happen, the lock would be released too soon.
"""
lockfile = None

"""
Current fields are:

	key, path, access date, access count

Therefore the elements are:

	path, access date, access count
"""

FIELD_SEPARATOR = ':'
ELEMENTS_PER_ROW = 3	# Attributes per row (everything but the name)

(F_PATH, F_ACCESS_TIME, F_ACCESS_COUNT) = range(ELEMENTS_PER_ROW)

def goto_file_path():
	try:
		return os.path.abspath(os.environ['GOTO_FILE'])
	except KeyError:
		return os.path.join(xdg_config_home, 'goto_favourites.list')


def escape_split(what, sep, splits):
	return re.split(r"(?<!\\)" + sep, what, splits)


def fill_list(l, count):
	""" Return a list with contents from `l` that has at least `count`
		string elements.
	"""
	if len(l) >= count:
		return l

	diff = count - len(l)

	return l + ([''] * diff)


# Deprecated import
import sqlite3

class deprecated(object):

	""" Deprecated methods for migration from goto's temporary
		sqlite3 DB to the original file format.
	"""

	@classmethod
	def goto_needs_migration(cls):
		return (os.path.exists(deprecated.goto_database_path()) and
				os.path.getsize(deprecated.goto_database_path()) != 0)

	@classmethod
	def migrate_to_file(cls):
		print >> sys.stderr, "Migrating your previous SQLite3 database to file format."
		data = deprecated.read_goto_database()

		DB_F_PATH = 'path'
		DB_F_NAME = 'name'
		DB_F_ACCESS_TIME = 'last_access'
		DB_F_ACCESS_COUNT = 'usage_count'

		migrated = dict()

		for (key, row) in data.items():
			migrated[key] = [''] * ELEMENTS_PER_ROW
			migrated[key][F_PATH] = unicode(row[DB_F_PATH])
			migrated[key][F_ACCESS_TIME] = unicode(row[DB_F_ACCESS_TIME])
			migrated[key][F_ACCESS_COUNT] = unicode(row[DB_F_ACCESS_COUNT])

		write_goto_file(migrated)
		os.unlink(deprecated.goto_database_path())
		print >> sys.stderr, "Migration completed successfully."

	@classmethod
	def goto_database_path(cls):
		try:
			return os.path.abspath(os.environ['GOTO_DATABASE'])
		except KeyError:
			return os.path.join(xdg_config_home, 'goto_tool.sqlite3')

	@classmethod
	def open_database(cls):
		if not os.path.exists(os.path.dirname(deprecated.goto_database_path())):
			os.makedirs(os.path.dirname(deprecated.goto_database_path()))
		con = sqlite3.connect(deprecated.goto_database_path())
		con.row_factory = sqlite3.Row
		return con

	@classmethod
	def read_goto_database(cls):
		"""
		Return stored directories as dictionary. The key is the name of the
		entry, the value is a dict of properties.

		Example:
		{'ex1':{'name': 'ex1', 'path':'/home/me/ex1', 'last_access': 11223344, 'usage_count': 10}}
		"""
		con = deprecated.open_database()

		cur = con.cursor()
		res = cur.execute("SELECT COUNT(*) FROM sqlite_master WHERE name='goto' AND type='table'")

		count = res.fetchone()[0]

		if count == 0 or os.path.getsize(deprecated.goto_database_path()) == 0:
			deprecated.init_database(con)
			return {}

		res = cur.execute("SELECT * FROM goto")
		rows = res.fetchall()
		con.close()

		return dict([ (r['name'], r) for r in rows ])


def acquire_lock(goto_path):
	""" Lock a special lock file in the same directory as the goto file
		resides in. If this file does not exist, it will be created.
		The lock is never explicitly released since on process exit
		the lock *SHOULD* be released by the OS (on fclose()).
	"""
	global lockfile # prevent lockfile from being GCed after this function

	lockfile_path = os.path.join(os.path.dirname(goto_path), 'goto.lock')
	lockfile = open(lockfile_path, 'w')
	fcntl.lockf(lockfile.fileno(), fcntl.LOCK_EX)

def read_goto_file():
	"""
	Return stored directories as dictionary. The key is the name of the
	entry, the value is a list of properties ordered like this:
	path, access date, access count.

	Example:
	{'ex1':['/home/me/ex1','11223344','10']}
	"""
	path = goto_file_path()

	# Acquire goto file lock
	acquire_lock(path)

	if deprecated.goto_needs_migration():
		deprecated.migrate_to_file()

	try:
		os.stat(path)
	except OSError:
		return {}

	def smap(x):
		y = map(lambda e: e.strip(), x)

		return y[0], fill_list(y[1:], ELEMENTS_PER_ROW)

	try:
		tuples = (smap(escape_split(n, FIELD_SEPARATOR, ELEMENTS_PER_ROW)) for n in file(path, 'r').readlines())
	except IOError as e:
		fatal("Something went wrong while opening the file '%s': %s" % (e, path))

	return dict(tuples)


def write_goto_file(dirs):
		path = goto_file_path()

		if not os.path.exists(os.path.dirname(path)):
				os.makedirs(os.path.dirname(path))

		data = "\n".join(["%s: %s" % (key, FIELD_SEPARATOR.join(props)) for (key,props) in dirs.items()])

		try:
				file(path, 'w').write(data)
		except IOError as e:
				fatal("Something went wrong while writing: %s" % (e))


def print_directory_by_name(dirname):
	dirs = read_goto_file()
	try:
		print dirs[dirname][F_PATH]
	except KeyError:
		fatal("Entry '%s' not found." % (dirname,))


def mark_entry_as_used(dirname):
	dirs = read_goto_file()

	if not dirs.has_key(dirname):
		fatal("Entry '%s' not found." % (dirname,))

	count = int(dirs[dirname][F_ACCESS_COUNT] or 0) + 1

	dirs[dirname][F_ACCESS_TIME] = str(time.time())
	dirs[dirname][F_ACCESS_COUNT] = str(count)

	write_goto_file(dirs)

	print "Entry '%s' marked as used." % (dirname,)


def lookup_entry(path):
	dirs = read_goto_file()
	matches = [d for (d,v) in dirs.items() if v[F_PATH] == os.path.abspath(path)]

	if len(matches) == 0:
		fatal("No entry for path '{}' found.".format(path))

	print "Path '{}' matches the following entries:".format(path)

	for match in matches:
		print match


def resolve_softlink(path):
	""" make an attempt to get the symlink from the current dir
	if wanted. If that attempt fails, just return the path. """
	if os.path.islink(path):
		return os.path.abspath(path)
	if path == '.':
		return os.environ['PWD']
	return path


def add_directory(name, path, soft=False):
	""" Don't take abspath if soft=True """
	dirs = read_goto_file()

	try:
		os.stat(path)
	except OSError:
		fatal('Path is not accessible: %s' % (path,))

	dirs[name] = [soft and resolve_softlink(path) or os.path.abspath(path)]

	write_goto_file(dirs)

	print "Entry '%s' added, points to '%s'." % (name, path)


def rm_directory(name):
	dirs = read_goto_file()

	try:
		del dirs[name]
	except KeyError:
		fatal("Entry '%s' does not exist." % (name,))

	write_goto_file(dirs)

	print "Entry '%s' removed." % (name,)


def mv_directory(oldName, newName):
	dirs = read_goto_file()

	try:
		dirs[newName] = dirs[oldName]
		del dirs[oldName]
	except KeyError:
		fatal("Entry '%s' does not exist." % (oldName,))

	write_goto_file(dirs)
	print "Entry '%s' was rennamed to '%s'." % (oldName, newName)


def list_directories():
	dirs = read_goto_file()
	print "\n".join(["%s: %s" % (key,row[F_PATH]) for (key,row) in dirs.items()])


def fatal(msg):
	print >> sys.stderr, msg

	# Use 2 instead of 1 to distingush between exceptional exit (1) and
	# controlled fatal exit (2).
	sys.exit(2)


def usage():
	fatal("goto-tool version {1}.\nUsage: {0} [get <name> | list | add [--soft] <name> <path> | rm <name> | path | lookup <path>]".format(
		sys.argv[0], VERSION))


def main():
	argv = sys.argv

	if len(argv) in (4,5) and argv[1] == "add":
		if argv[2] == "--soft" and len(argv) == 5:
			add_directory(argv[3], argv[4], soft=True)
		elif argv[2] == "--soft":
			usage()
		else:
			add_directory(argv[2], argv[3])

	elif len(argv) == 3 and argv[1] == "rm":
		rm_directory(argv[2])

	elif len(argv) == 4 and argv[1] == "mv":
		mv_directory(argv[2],argv[3])

	elif len(argv) == 3 and argv[1] == "get":
		print_directory_by_name(argv[2])

	elif len(argv) == 3 and argv[1] == "use":
		mark_entry_as_used(argv[2])

	elif len(argv) == 3 and argv[1] == "lookup":
		lookup_entry(argv[2])

	elif len(argv) == 2 and argv[1] == "list":
		list_directories()

	elif len(argv) == 2 and argv[1] == "path":
		print goto_file_path()

	else:
		usage()


if __name__ == "__main__":
	main()

# vim: noexpandtab tabstop=4
